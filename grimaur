#!/usr/bin/env python3
"""grimaur: Fetch, inspect, search, list, update, and install Arch Linux AUR packages.

By default this tool queries the official AUR RPC API and automatically falls back to
the git mirror at https://github.com/archlinux/aur.git when the endpoint is
unavailable. Each package lives on its own branch in the mirror, and grimaur can
recursively resolve and install dependencies by building packages locally with
makepkg. Official repository dependencies are installed with pacman when they are
missing.

## /* SPDX-FileCopyrightText: 2025
# (O) Marcus A. <placeholder@placeholder.com>
# (C) Eihdran L. <hadean-eon-dev@proton.me>

##  SPDX-License-Identifier: MIT */

Requirements: git, makepkg, pacman, and (for installing official packages) sudo/root.
"""

from __future__ import annotations

import argparse
import heapq
import json
import os
import re
import shutil
import subprocess
import sys
import urllib.error
import urllib.parse
import urllib.request
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass
from pathlib import Path
from typing import Any
from collections.abc import Iterable, Sequence


def get_aur_remote() -> str:
    return (
        "git@github.com:archlinux/aur.git"
        if USE_SSH
        else "https://github.com/archlinux/aur.git"
    )


def get_official_aur_git_base() -> str:
    return "ssh://aur@aur.archlinux.org" if USE_SSH else "https://aur.archlinux.org"


CGIT_RAW_BASE = "https://aur.archlinux.org/cgit/aur.git/plain"
AUR_RPC_ENDPOINT = "https://aur.archlinux.org/rpc/"
GITHUB_RAW_BASE = "https://raw.githubusercontent.com/archlinux/aur"
_VCS_SUFFIXES = ("-git", "-vcs", "-svn", "-hg", "-bzr", "-darcs", "-cvs")

RESET = "\033[0m"
BOLD = "\033[1m"
GREEN = "\033[32m"
CYAN = "\033[36m"
YELLOW = "\033[33m"
DIM = "\033[2m"

USE_COLOR = False
USE_AUR_RPC = False
FORCE_GIT_MIRROR = False
USE_SSH = False
_INSTALLED_CACHE: set[str] | None = None
_PROVIDES_CACHE: dict[str, set[str] | None] = {}
_VIRTUAL_PROVIDER_CACHE: dict[str, str | None] = {}
_AUR_INFO_CACHE: dict[str, dict | None] = {}
_RPC_FALLBACK_NOTIFIED = False

_COMMON_AUR_SUFFIXES = ("-bin",)

_GLOBAL_FLAG_OPTIONS = {
    "--refresh",
    "--no-color",
    "--aur-rpc",
    "--git-mirror",
    "--use-ssh",
}
_GLOBAL_VALUE_OPTIONS = {"--dest-root"}


def style(text: str, *codes: str) -> str:
    if not USE_COLOR or not codes:
        return text
    return "".join(codes) + text + RESET


def disable_aur_rpc(reason: str) -> None:
    global USE_AUR_RPC, _RPC_FALLBACK_NOTIFIED
    if FORCE_GIT_MIRROR or not USE_AUR_RPC:
        return
    USE_AUR_RPC = False
    if _RPC_FALLBACK_NOTIFIED:
        return

    # Provide user-friendly messages based on error type
    summary = reason.strip().splitlines()[0] if reason else "unknown error"
    if "Too many package results" in reason:
        message = "AUR RPC returned too many results; using git mirror instead..."
    elif "Connection refused" in reason or "timed out" in reason:
        message = "AUR RPC unavailable; using git mirror instead..."
    elif "reset by peer" in reason.lower():
        message = "AUR RPC connection failed; using git mirror instead..."
    elif "status" in reason.lower():
        message = f"AUR RPC error ({summary}); using git mirror instead..."
    else:
        message = f"AUR RPC unavailable ({summary}); using git mirror instead..."

    if sys.stderr.isatty():
        print(file=sys.stderr)  # Clear the progress line first
    print(style(message, YELLOW), file=sys.stderr)
    _RPC_FALLBACK_NOTIFIED = True


def prompt_confirm(message: str) -> bool:
    if not sys.stdin.isatty():
        return False
    try:
        response = input(message)
    except EOFError:
        return False
    return response.strip().lower() in {"y", "yes"}


def is_debug_package(name: str) -> bool:
    return name.endswith("-debug")


def is_vcs_package(name: str) -> bool:
    return any(name.endswith(suffix) for suffix in _VCS_SUFFIXES)


class AurGitError(RuntimeError):
    """Wraps fatal errors coming from the helper."""


@dataclass(frozen=True)
class DependencySet:
    depends: set[str]
    makedepends: set[str]
    checkdepends: set[str]
    optdepends: set[str]

    @property
    def all_build_deps(self) -> set[str]:
        return self.depends | self.makedepends


@dataclass(frozen=True)
class SearchResult:
    name: str
    version: str | None
    description: str | None
    installed: bool
    score: int
    votes: int | None = None
    is_orphan: bool | None = None


@dataclass(frozen=True)
class UpdateCandidate:
    name: str
    installed_version: str | None
    target_version: str | None
    remote_head: str | None
    local_head: str | None


def aur_rpc_call(params: dict[str, Any]) -> dict[str, Any]:
    query_params: dict[str, Any] = {"v": "5"}
    query_params.update(params)
    query = urllib.parse.urlencode(query_params, doseq=True)
    url = f"{AUR_RPC_ENDPOINT}?{query}"
    try:
        with urllib.request.urlopen(url, timeout=10) as response:
            status = response.getcode()
            if status != 200:
                disable_aur_rpc(f"status {status}")
                raise AurGitError(f"AUR RPC request failed with status {status}")
            payload = response.read()
    except urllib.error.URLError as exc:
        disable_aur_rpc(str(exc))
        raise AurGitError(f"Failed to contact AUR RPC: {exc}") from exc
    except Exception as exc:  # pragma: no cover - unexpected transport issues
        disable_aur_rpc(str(exc))
        raise AurGitError(f"Failed to contact AUR RPC: {exc}") from exc
    try:
        data = json.loads(payload.decode())
    except (UnicodeDecodeError, json.JSONDecodeError) as exc:
        disable_aur_rpc("invalid JSON payload")
        raise AurGitError("Failed to decode AUR RPC response") from exc
    if data.get("type") == "error":
        error_msg = str(data.get("error") or "Unknown AUR RPC error")
        disable_aur_rpc(error_msg)
        raise AurGitError(error_msg)
    return data


def aur_rpc_info(package: str) -> dict | None:
    if package in _AUR_INFO_CACHE:
        return _AUR_INFO_CACHE[package]
    try:
        data = aur_rpc_call({"type": "info", "arg[]": [package]})
    except AurGitError:
        _AUR_INFO_CACHE[package] = None
        return None
    results = data.get("results")
    match: dict | None = None
    if isinstance(results, list):
        for entry in results:
            if isinstance(entry, dict) and entry.get("Name") == package:
                match = entry
                break
        if match is None:
            for entry in results:
                if isinstance(entry, dict) and entry.get("PackageBase") == package:
                    match = entry
                    break
    _AUR_INFO_CACHE[package] = match
    return match


def dependency_set_from_rpc(info: dict) -> DependencySet:
    def gather(key: str, normalize: bool = True) -> set[str]:
        values: set[str] = set()
        items = info.get(key)
        if not isinstance(items, list):
            return values
        for item in items:
            if not isinstance(item, str):
                continue
            entry = _normalize_dep(item) if normalize else item.strip()
            if entry:
                values.add(entry)
        return values

    depends = gather("Depends")
    makedepends = gather("MakeDepends")
    checkdepends = gather("CheckDepends")
    optdepends = gather("OptDepends", normalize=False)
    return DependencySet(depends, makedepends, checkdepends, optdepends)


def aur_rpc_search_results(pattern: str) -> list[dict]:
    try:
        data = aur_rpc_call({"type": "search", "arg": pattern})
    except AurGitError:
        return []
    results = data.get("results")
    if not isinstance(results, list):
        return []
    return [entry for entry in results if isinstance(entry, dict)]


def aur_rpc_suggest(prefix: str) -> list[str]:
    try:
        data = aur_rpc_call({"type": "suggest", "arg": prefix})
    except AurGitError:
        return []
    results = data.get("results")
    if not isinstance(results, list):
        return []
    suggestions: list[str] = []
    for entry in results:
        if isinstance(entry, str):
            suggestions.append(entry)
    return suggestions


def run_command(
    cmd: Sequence[str],
    *,
    cwd: Path | None = None,
    capture: bool = False,
    check: bool = True,
    env: dict | None = None,
) -> subprocess.CompletedProcess | str:
    """Run a command, optionally capturing stdout, and surface errors nicely."""
    try:
        completed = subprocess.run(
            list(cmd),
            cwd=str(cwd) if cwd else None,
            check=check,
            text=True,
            capture_output=capture,
            env=env,
        )
    except FileNotFoundError as exc:  # e.g. git not installed
        raise AurGitError(f"Required command not found: {cmd[0]}") from exc
    except subprocess.CalledProcessError as exc:
        raise AurGitError(
            f"Command failed with exit code {exc.returncode}: {' '.join(cmd)}\n{exc.stderr or ''}"
        ) from exc

    if capture:
        return completed.stdout
    return completed


def ensure_clone(
    package: str,
    dest_root: Path,
    *,
    refresh: bool = False,
    force_reclone: bool = False,
    repo_url: str | None = None,
) -> Path:
    """Clone or refresh the package branch into dest_root/package."""
    dest_root.mkdir(parents=True, exist_ok=True)
    package_dir = dest_root / package

    if package_dir.exists() and not (package_dir / ".git").is_dir():
        if force_reclone:
            shutil.rmtree(package_dir)
        else:
            raise AurGitError(
                f"Destination '{package_dir}' exists but is not a git repository. "
                "Use --force to overwrite."
            )

    if repo_url:
        if (
            package_dir.exists()
            and (package_dir / ".git").is_dir()
            and not force_reclone
        ):
            if refresh:
                run_command(["git", "-C", str(package_dir), "fetch", "origin"])
                run_command(
                    ["git", "-C", str(package_dir), "reset", "--hard", "origin/HEAD"]
                )
            return package_dir
        if package_dir.exists():
            shutil.rmtree(package_dir)
        run_command(["git", "clone", repo_url, str(package_dir)])
    elif USE_AUR_RPC:
        remote_url = f"{get_official_aur_git_base()}/{package}.git"
        if (
            package_dir.exists()
            and (package_dir / ".git").is_dir()
            and not force_reclone
        ):
            if refresh:
                run_command(["git", "-C", str(package_dir), "fetch", "origin"])
                try:
                    _reset_git_worktree(
                        package_dir,
                        (
                            "origin/HEAD",
                            "origin/master",
                            "origin/main",
                            f"origin/{package}",
                        ),
                    )
                except AurGitError:
                    if package_dir.exists():
                        shutil.rmtree(package_dir)
                    return ensure_clone(
                        package,
                        dest_root,
                        refresh=False,
                        force_reclone=True,
                    )
            return package_dir
        if package_dir.exists():
            shutil.rmtree(package_dir)
        run_command(["git", "clone", remote_url, str(package_dir)])
    else:
        if (
            package_dir.exists()
            and (package_dir / ".git").is_dir()
            and not force_reclone
        ):
            if refresh:
                run_command(["git", "-C", str(package_dir), "fetch", "origin", package])
                try:
                    _reset_git_worktree(package_dir, (f"origin/{package}",))
                except AurGitError:
                    if package_dir.exists():
                        shutil.rmtree(package_dir)
                    return ensure_clone(
                        package,
                        dest_root,
                        refresh=False,
                        force_reclone=True,
                    )
            return package_dir
        if package_dir.exists():
            shutil.rmtree(package_dir)
        run_command(
            [
                "git",
                "clone",
                "--branch",
                package,
                "--single-branch",
                get_aur_remote(),
                str(package_dir),
            ]
        )

    return package_dir


def read_srcinfo(package_dir: Path) -> str:
    srcinfo_path = package_dir / ".SRCINFO"
    if srcinfo_path.exists():
        return srcinfo_path.read_text()
    # Fallback to generating on the fly
    output = run_command(["makepkg", "--printsrcinfo"], cwd=package_dir, capture=True)
    return str(output)


_SRCINFO_KEYS = {
    "depends",
    "makedepends",
    "checkdepends",
    "optdepends",
    "pkgname",
    "pkgbase",
    "pkgdesc",
}


def parse_dependencies(srcinfo_content: str) -> tuple[str, str | None, DependencySet]:
    pkgbase = ""
    pkgdesc = None
    depends: set[str] = set()
    makedepends: set[str] = set()
    checkdepends: set[str] = set()
    optdepends: set[str] = set()

    for raw_line in srcinfo_content.splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        key, value = (part.strip() for part in line.split("=", 1))
        if key not in _SRCINFO_KEYS:
            continue
        if key == "pkgbase" and not pkgbase:
            pkgbase = value
            continue
        if key == "pkgdesc" and not pkgdesc:
            pkgdesc = value
            continue
        if key == "optdepends":
            optdepends.add(value)
            continue
        if key == "depends":
            depends.update([_normalize_dep(value)])
        elif key == "makedepends":
            makedepends.update([_normalize_dep(value)])
        elif key == "checkdepends":
            checkdepends.update([_normalize_dep(value)])

    if not pkgbase:
        raise AurGitError("Failed to parse pkgbase from .SRCINFO")
    return (
        pkgbase,
        pkgdesc,
        DependencySet(depends, makedepends, checkdepends, optdepends),
    )


_DEP_SPLIT_RE = re.compile(r"[<>~=]+")


def _normalize_dep(dep_entry: str) -> str:
    dep_entry = dep_entry.strip()
    if not dep_entry:
        return dep_entry
    dep_entry = dep_entry.split(":", 1)[-1]  # strip repo qualifier if present
    dep_entry = _DEP_SPLIT_RE.split(dep_entry)[0]
    return dep_entry.strip()


def _pkgbase_guesses(dep: str) -> list[str]:
    """Return possible pkgbase names for split packages sharing a prefix."""
    parts = dep.split("-")
    guesses: list[str] = []
    # Walk backwards dropping the last segment each time (foo-bar-baz -> foo-bar, foo)
    for index in range(len(parts) - 1, 0, -1):
        candidate = "-".join(parts[:index])
        if candidate:
            guesses.append(candidate)
    return guesses


def _parse_srcinfo_metadata(srcinfo_content: str) -> tuple[str | None, str | None]:
    pkgver = None
    pkgrel = None
    epoch = None
    description = None
    for raw_line in srcinfo_content.splitlines():
        line = raw_line.strip()
        if not line or "=" not in line:
            continue
        key, value = (part.strip() for part in line.split("=", 1))
        if key == "pkgver" and not pkgver:
            pkgver = value
        elif key == "pkgrel" and not pkgrel:
            pkgrel = value
        elif key == "epoch" and not epoch:
            epoch = value
        elif key == "pkgdesc" and not description:
            description = value
    if pkgver or pkgrel or epoch:
        version_parts: list[str] = []
        if epoch and epoch not in {"", "0"}:
            version_parts.append(f"{epoch}:")
        if pkgver:
            version_parts.append(pkgver)
        if pkgrel and pkgver:
            version_parts.append(f"-{pkgrel}")
        version = "".join(version_parts) if version_parts else None
    else:
        version = None
    return version, description


def _reset_git_worktree(package_dir: Path, refs: Sequence[str]) -> None:
    for ref in refs:
        try:
            run_command(
                [
                    "git",
                    "-C",
                    str(package_dir),
                    "rev-parse",
                    "--verify",
                    ref,
                ],
                capture=True,
            )
        except AurGitError:
            continue
        run_command(
            [
                "git",
                "-C",
                str(package_dir),
                "reset",
                "--hard",
                ref,
            ]
        )
        return
    raise AurGitError(
        f"Could not reset {package_dir.name} to any of: {', '.join(refs)}"
    )


def is_regex(pattern: str) -> bool:
    """Check if pattern contains regex metacharacters."""
    regex_chars = r'.*+?[]{}()^$|\\'
    return any(char in pattern for char in regex_chars)


def compute_match_score(
    name: str,
    *,
    regex: re.Pattern | None,
    needle: str | None,
) -> int | None:
    if regex is not None:
        match = regex.search(name)
        if not match:
            return None
        start = match.start()
        span = match.end() - match.start()
    else:
        if needle is None:
            raise ValueError("needle required when regex is None")
        lowered = name.lower()
        idx = lowered.find(needle)
        if idx == -1:
            return None
        start = idx
        span = len(needle)
    # Lower score is better match
    return start * 1000 + len(name) - span


def _pacman_returns_zero(args: Sequence[str]) -> bool:
    try:
        proc = subprocess.run(
            list(args),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            text=True,
        )
    except FileNotFoundError as exc:
        raise AurGitError(
            "pacman command not found; this tool must run on Arch Linux"
        ) from exc
    return proc.returncode == 0


def invalidate_installed_cache() -> None:
    global _INSTALLED_CACHE
    _INSTALLED_CACHE = None


def installed_package_set() -> set[str]:
    global _INSTALLED_CACHE
    if _INSTALLED_CACHE is None:
        output = run_command(["pacman", "-Qq"], capture=True)
        _INSTALLED_CACHE = set(str(output).split())
    return _INSTALLED_CACHE


def is_installed(package: str) -> bool:
    return package in installed_package_set()


def exists_in_sync_repo(package: str) -> bool:
    return _pacman_returns_zero(["pacman", "-Si", package])


def is_dependency_satisfied(dep: str) -> bool:
    try:
        proc = subprocess.run(
            ["pacman", "-T", dep],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            text=True,
        )
    except FileNotFoundError as exc:
        raise AurGitError(
            "pacman command not found; this tool must run on Arch Linux"
        ) from exc
    return proc.returncode == 0


def package_provides(package: str) -> set[str] | None:
    if package in _PROVIDES_CACHE:
        return _PROVIDES_CACHE[package]
    provides: set[str] = set()
    info: dict | None = None
    if USE_AUR_RPC:
        info = aur_rpc_info(package)
        if info:
            name = info.get("Name")
            if isinstance(name, str):
                normalized = _normalize_dep(name)
                if normalized:
                    provides.add(normalized)
            pkgbase_value = info.get("PackageBase")
            if isinstance(pkgbase_value, str):
                normalized = _normalize_dep(pkgbase_value)
                if normalized:
                    provides.add(normalized)
            rpc_provides = info.get("Provides")
            if isinstance(rpc_provides, list):
                for value in rpc_provides:
                    if not isinstance(value, str):
                        continue
                    normalized = _normalize_dep(value)
                    if normalized:
                        provides.add(normalized)
    srcinfo = fetch_git_file(package, ".SRCINFO")
    if not srcinfo:
        if not provides:
            _PROVIDES_CACHE[package] = None
            return None
        _PROVIDES_CACHE[package] = provides
        return provides
    for raw_line in srcinfo.splitlines():
        line = raw_line.strip()
        if not line or "=" not in line:
            continue
        key, value = (part.strip() for part in line.split("=", 1))
        if key == "pkgname" or key == "provides":
            normalized = _normalize_dep(value)
            if normalized:
                provides.add(normalized)
    _PROVIDES_CACHE[package] = provides
    return provides


def _search_aur_candidates(dep: str, *, limit: int = 25) -> list[str]:
    if USE_AUR_RPC:
        results = _search_aur_candidates_rpc(dep, limit=limit)
        if results or USE_AUR_RPC:
            return results
    patterns = [
        f"refs/heads/{dep}",
        f"refs/heads/{dep}-*",
        f"refs/heads/*-{dep}",
    ]
    if len(dep) >= 3:
        patterns.append(f"refs/heads/*{dep}*")
    seen: set[str] = set()
    results: list[str] = []
    for pattern in patterns:
        try:
            output = run_command(
                ["git", "ls-remote", "--heads", get_aur_remote(), pattern],
                capture=True,
            )
        except AurGitError:
            continue
        for raw_line in str(output).splitlines():
            parts = raw_line.split()
            if len(parts) != 2:
                continue
            ref = parts[1]
            name = ref.split("/")[-1]
            if not name or name in seen:
                continue
            seen.add(name)
            results.append(name)
            if len(results) >= limit:
                return results
    return results


def _search_aur_candidates_rpc(dep: str, *, limit: int) -> list[str]:
    results = aur_rpc_search_results(dep)
    seen: set[str] = set()
    names: list[str] = []
    for entry in results:
        for key in ("Name", "PackageBase"):
            value = entry.get(key)
            if not isinstance(value, str):
                continue
            if value in seen:
                continue
            seen.add(value)
            names.append(value)
            if len(names) >= limit:
                return names
    return names


def resolve_aur_dependency(dep: str) -> str | None:
    if dep in _VIRTUAL_PROVIDER_CACHE:
        return _VIRTUAL_PROVIDER_CACHE[dep]
    if exists_in_aur_mirror(dep):
        _VIRTUAL_PROVIDER_CACHE[dep] = dep
        return dep
    candidates: list[str] = []
    seen: set[str] = set()

    def add_candidate(name: str) -> None:
        if not name or name in seen:
            return
        seen.add(name)
        candidates.append(name)

    add_candidate(dep)
    for suffix in (*_VCS_SUFFIXES, *_COMMON_AUR_SUFFIXES):
        add_candidate(f"{dep}{suffix}")
    for base_candidate in _pkgbase_guesses(dep):
        add_candidate(base_candidate)
    for candidate in candidates:
        provides = package_provides(candidate)
        if not provides:
            continue
        if dep in provides:
            _VIRTUAL_PROVIDER_CACHE[dep] = candidate
            return candidate
    search_terms = [dep, *(_pkgbase_guesses(dep))]
    seen_search: set[str] = set()
    for term in search_terms:
        if term in seen_search:
            continue
        seen_search.add(term)
        for candidate in _search_aur_candidates(term):
            if candidate in seen:
                continue
            seen.add(candidate)
            provides = package_provides(candidate)
            if not provides:
                continue
            if dep in provides:
                _VIRTUAL_PROVIDER_CACHE[dep] = candidate
                return candidate
    _VIRTUAL_PROVIDER_CACHE[dep] = None
    return None


def resolve_official_dependency(dep: str) -> str | None:
    """Return the repo package that satisfies dep, accounting for providers."""
    if exists_in_sync_repo(dep):
        return dep
    try:
        output = run_command(
            [
                "pacman",
                "-Sp",
                "--print-format",
                "%n",
                dep,
            ],
            capture=True,
        )
    except AurGitError:
        return None
    providers = [line.strip() for line in str(output).splitlines() if line.strip()]
    if not providers:
        return None
    return providers[0]


def exists_in_aur_mirror(package: str) -> bool:
    if is_debug_package(package):
        return True
    if USE_AUR_RPC:
        info = aur_rpc_info(package)
        if info:
            return True
        if USE_AUR_RPC:
            return False
    try:
        output = run_command(
            [
                "git",
                "ls-remote",
                "--heads",
                get_aur_remote(),
                package,
            ],
            capture=True,
        )
    except AurGitError:
        return False
    return bool(str(output).strip())


def list_foreign_packages() -> dict[str, str]:
    try:
        output = run_command(["pacman", "-Qm"], capture=True, check=False)
    except AurGitError:
        return {}

    names: dict[str, str] = {}
    for line in str(output).splitlines():
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) >= 2:
            names[parts[0]] = parts[1]
        else:
            names[parts[0]] = ""
    return names


def get_local_head(package_dir: Path) -> str | None:
    if not (package_dir / ".git").is_dir():
        return None
    try:
        output = run_command(
            ["git", "-C", str(package_dir), "rev-parse", "HEAD"], capture=True
        )
    except AurGitError:
        return None
    return str(output).strip() or None


def get_remote_head(package: str) -> str | None:
    try:
        if USE_AUR_RPC:
            output = run_command(
                [
                    "git",
                    "ls-remote",
                    f"{get_official_aur_git_base()}/{package}.git",
                    "HEAD",
                ],
                capture=True,
            )
        else:
            output = run_command(
                [
                    "git",
                    "ls-remote",
                    "--heads",
                    get_aur_remote(),
                    package,
                ],
                capture=True,
            )
    except AurGitError:
        return None
    for line in str(output).splitlines():
        parts = line.split()
        if not parts:
            continue
        sha = parts[0]
        if sha:
            return sha
    return None


def get_installed_version(package: str) -> str | None:
    try:
        output = run_command(["pacman", "-Qi", package], capture=True)
    except AurGitError:
        return None
    for line in str(output).splitlines():
        if line.lower().startswith("version"):
            _, value = line.split(":", 1)
            return value.strip()
    return None


def list_installed_packages() -> None:
    foreign = list_foreign_packages()

    if not foreign:
        print("No foreign packages installed")
        return

    print(style(f"Installed foreign packages ({len(foreign)}):", CYAN))

    for name in sorted(foreign.keys()):
        version = foreign[name]
        print(f"  {style(name, BOLD)} {style(version, GREEN)}")


def fetch_git_file(package: str, path: str) -> str | None:
    safe_package = urllib.parse.quote(package)
    safe_path = path.lstrip("/")
    if USE_AUR_RPC:
        url = f"{CGIT_RAW_BASE}/{safe_path}?h={safe_package}"
    else:
        url = f"{GITHUB_RAW_BASE}/{safe_package}/{safe_path}"
    try:
        with urllib.request.urlopen(url, timeout=10) as response:
            if response.status != 200:
                return None
            data = response.read()
    except urllib.error.URLError:
        return None
    try:
        return data.decode()
    except UnicodeDecodeError:
        return None


def git_srcinfo_metadata(package: str) -> tuple[str, str | None] | None:
    if USE_AUR_RPC:
        info = aur_rpc_info(package)
        if not info:
            return None
        version = info.get("Version")
        description = info.get("Description")
        if isinstance(version, str) or isinstance(description, str):
            version_result = version if isinstance(version, str) else None
            description_result = description if isinstance(description, str) else None
            if version_result is not None:  # Only return if version is valid
                return (version_result, description_result)
        # fallback to raw .SRCINFO if fields missing
    srcinfo = fetch_git_file(package, ".SRCINFO")
    if not srcinfo:
        return None
    version, description = _parse_srcinfo_metadata(srcinfo)
    if not version:  # Changed: only check version since it's required
        return None
    return version, description


def install_official_packages(packages: Iterable[str], *, noconfirm: bool) -> None:
    pkgs = sorted(set(packages))
    if not pkgs:
        return
    cmd: list[str] = ["pacman", "-S", "--needed"]
    if noconfirm:
        cmd.append("--noconfirm")
    cmd.extend(pkgs)
    if os.geteuid() != 0:
        cmd.insert(0, "sudo")
    print(f"Installing official packages: {' '.join(pkgs)}")
    run_command(cmd)
    invalidate_installed_cache()


def collect_missing_official_packages(
    package: str,
    dest_root: Path,
    *,
    refresh: bool,
    visited: set[str] | None = None,
) -> tuple[set[str], set[str]]:
    """Return official packages missing for the dependency tree rooted at package."""
    visited = visited or set()
    if package in visited:
        return set(), set()
    visited.add(package)

    info: dict | None = None
    deps: DependencySet | None = None
    if USE_AUR_RPC:
        info = aur_rpc_info(package)
        if info:
            deps = dependency_set_from_rpc(info)
    if deps is None:
        package_dir = ensure_clone(package, dest_root, refresh=refresh)
        srcinfo = read_srcinfo(package_dir)
        _, _, deps = parse_dependencies(srcinfo)

    missing_official: set[str] = set()
    unresolved: set[str] = set()

    for dep in sorted(deps.all_build_deps):
        if dep == package:
            continue
        if is_dependency_satisfied(dep):
            continue
        provider = resolve_official_dependency(dep)
        if provider:
            missing_official.add(provider)
            continue
        aur_provider = resolve_aur_dependency(dep)
        if aur_provider:
            child_missing, child_unresolved = collect_missing_official_packages(
                aur_provider,
                dest_root,
                refresh=refresh,
                visited=visited,
            )
            missing_official.update(child_missing)
            unresolved.update(child_unresolved)
            continue
        if _pacman_returns_zero(["pacman", "-Sp", dep]):
            missing_official.add(dep)
            continue
        unresolved.add(dep)

    return missing_official, unresolved


def build_and_install(package_dir: Path, *, noconfirm: bool, refresh: bool = False) -> None:
    pkgbuild_path = package_dir / "PKGBUILD"
    if not pkgbuild_path.exists():
        raise AurGitError(f"PKGBUILD missing at {pkgbuild_path}")
    flags = "-sif" if refresh else "-si"
    cmd = ["makepkg", flags, "--needed"]
    if noconfirm:
        cmd.append("--noconfirm")
    print(f"Building {package_dir.name} with makepkg")
    run_command(cmd, cwd=package_dir)
    print(f"Built package artifacts remain under {package_dir}")
    invalidate_installed_cache()


def install_package(
    package: str,
    dest_root: Path,
    *,
    refresh: bool,
    noconfirm: bool,
    visited: set[str] | None = None,
    preinstalled_official: set[str] | None = None,
    repo_url: str | None = None,
) -> None:
    visited = visited or set()
    if package in visited:
        return
    visited.add(package)

    if is_installed(package):
        installed_ver = get_installed_version(package)
        print(f"Package {style(package, BOLD)} is already installed ({installed_ver})")
        if not noconfirm and not prompt_confirm(style("Reinstall? [y/N]: ", YELLOW)):
            print("Cancelled installation.")
            return

    if preinstalled_official is None:
        preinstalled_official = set()

    package_dir: Path | None = None
    info: dict | None = None
    if repo_url:
        # Skip AUR RPC when using custom repo URL
        package_dir = ensure_clone(
            package, dest_root, refresh=refresh, repo_url=repo_url
        )
    elif USE_AUR_RPC:
        info = aur_rpc_info(package)
        if info is None and USE_AUR_RPC:
            raise AurGitError(f"Package '{package}' not found via AUR RPC")
    if info:
        pkgdesc = (
            info.get("Description")
            if isinstance(info.get("Description"), str)
            else None
        )
        deps = dependency_set_from_rpc(info)
    else:
        if package_dir is None:
            package_dir = ensure_clone(
                package, dest_root, refresh=refresh, repo_url=repo_url
            )
        srcinfo = read_srcinfo(package_dir)
        _, pkgdesc, deps = parse_dependencies(srcinfo)
    if pkgdesc:
        print(f"==> {package}: {pkgdesc}")
    else:
        print(f"==> {package}")

    missing_official: set[str] = set()
    aur_dependencies: set[str] = set()
    unresolved: set[str] = set()
    virtual_providers: dict[str, set[str]] = {}
    for dep in sorted(deps.all_build_deps):
        if dep == package:
            continue
        if is_dependency_satisfied(dep):
            continue
        provider = resolve_official_dependency(dep)
        if provider:
            missing_official.add(provider)
            continue
        aur_provider = resolve_aur_dependency(dep)
        if aur_provider:
            aur_dependencies.add(aur_provider)
            if aur_provider != dep:
                virtual_providers.setdefault(aur_provider, set()).add(dep)
            continue
        if _pacman_returns_zero(["pacman", "-Sp", dep]):
            missing_official.add(dep)
            continue
        unresolved.add(dep)

    if unresolved:
        missing_list = ", ".join(sorted(unresolved))
        raise AurGitError(f"Could not resolve providers for: {missing_list}")

    if missing_official:
        to_install = missing_official - preinstalled_official
        if to_install:
            install_official_packages(to_install, noconfirm=noconfirm)
            preinstalled_official.update(to_install)

    if aur_dependencies and not noconfirm:
        print(style("The following AUR dependencies are required:", CYAN))
        for dep_pkg in sorted(aur_dependencies):
            provides = virtual_providers.get(dep_pkg)
            if provides:
                provides_label = ", ".join(sorted(provides))
                print(f"  {dep_pkg} (provides {provides_label})")
            else:
                print(f"  {dep_pkg}")
        if not prompt_confirm(
            style("Proceed with building these dependencies? [y/N]: ", YELLOW)
        ):
            raise AurGitError("Installation aborted by user")

    for aur_dep in sorted(aur_dependencies):
        install_package(
            aur_dep,
            dest_root,
            refresh=refresh,
            noconfirm=noconfirm,
            visited=visited,
            preinstalled_official=preinstalled_official,
        )

    if package_dir is None:
        package_dir = ensure_clone(
            package, dest_root, refresh=refresh, repo_url=repo_url
        )

    build_and_install(package_dir, noconfirm=noconfirm, refresh=refresh)


def remove_package(
    package: str,
    dest_root: Path,
    *,
    noconfirm: bool,
    remove_cache: bool,
) -> None:
    # Check if package is installed
    if not is_installed(package):
        print(f"Package {style(package, BOLD)} is not installed")
        return

    # Remove with pacman -Rns
    cmd: list[str] = ["pacman", "-Rns", package]
    if noconfirm:
        cmd.append("--noconfirm")

    if os.geteuid() != 0:
        cmd.insert(0, "sudo")

    print(f"Removing package {style(package, BOLD)}")
    try:
        run_command(cmd)
        invalidate_installed_cache()
        print(f"Successfully removed {style(package, GREEN)}")
    except AurGitError as exc:
        print(f"Failed to remove package: {exc}", file=sys.stderr)
        return

    # Optionally remove cached directory
    if remove_cache:
        package_dir = dest_root / package
        if package_dir.exists():
            print(f"Removing cached directory {package_dir}")
            shutil.rmtree(package_dir)
            print(f"Removed cache for {style(package, GREEN)}")
        else:
            print(f"No cache found at {package_dir}")


def get_ignored_packages() -> set[str]:
    ignored: set[str] = set()
    pacman_conf = Path("/etc/pacman.conf")

    if not pacman_conf.exists():
        return ignored

    content = pacman_conf.read_text()

    for line in content.splitlines():
        line = line.strip()

        # Skip comments and empty lines
        if not line or line.startswith("#"):
            continue

        # Look for IgnorePkg lines
        if line.startswith("IgnorePkg"):
            # Format: IgnorePkg = pkg1 pkg2 pkg3
            if "=" in line:
                _, packages = line.split("=", 1)
                for pkg in packages.split():
                    ignored.add(pkg.strip())

    return ignored


def update_packages(
    dest_root: Path,
    *,
    refresh: bool,
    noconfirm: bool,
    update_system: bool,
    include_devel: bool,
    targets: Sequence[str] | None = None,
    index_only: bool = False,
    download_only: bool = False,
    install_only: bool = False,
    system_only: bool = False,
) -> None:
    ignored = get_ignored_packages()

    if update_system:
        if install_only:
            cmd: list[str] = ["pacman", "-Su"]
        else:
            cmd = ["pacman", "-Sy"]
            if download_only:
                cmd[1] += "uw"
            elif not index_only:
                cmd[1] += "u"

        if noconfirm:
            cmd.append("--noconfirm")

        if os.geteuid() != 0:
            cmd.insert(0, "sudo")

        print(style("Updating system packages first...", CYAN))
        try:
            run_command(cmd)
            invalidate_installed_cache()
        except AurGitError as exc:
            print(f"System update failed: {exc}", file=sys.stderr)
            if not noconfirm and not prompt_confirm(
                style("Continue with AUR updates? [y/N]: ", YELLOW)
            ):
                return

        if download_only:
            print(
                style(
                    "WARNING: System packages downloaded but not installed (partial update state).",
                    YELLOW,
                )
            )
            print(
                style(
                    "Run 'grimaur update --global --install' or 'sudo pacman -Su' to install them.",
                    YELLOW,
                )
            )

        if system_only:
            return

    candidates: list[tuple[str, str | None]]
    if targets:
        seen: set[str] = set()
        candidates = []
        for pkg in targets:
            if pkg in seen:
                continue
            seen.add(pkg)
            candidates.append((pkg, get_installed_version(pkg)))
    else:
        foreign = list_foreign_packages()
        if not foreign:
            print("No foreign packages reported by pacman -Qm")
            return
        candidates = list(foreign.items())

    missing: list[str] = []
    pending_updates: list[UpdateCandidate] = []
    skip_devel = not include_devel and not targets

    for package, installed_version in candidates:
        if is_debug_package(package):
            continue
        # Skip ignored packages
        if package in ignored:
            print(f"Skipping {package} (in IgnorePkg)", file=sys.stderr)
            continue
        if skip_devel and is_vcs_package(package):
            continue

        remote_version: str | None = None
        remote_head: str | None = None
        local_head: str | None = None

        meta = git_srcinfo_metadata(package)
        if meta:
            remote_version = meta[0]

        if remote_version and is_vcs_package(package):
            remote_version = None

        if remote_version is None:
            remote_head = get_remote_head(package)
            if remote_head is None:
                missing.append(package)
                continue
            package_dir = dest_root / package
            local_head = get_local_head(package_dir)

        if installed_version and remote_version and installed_version == remote_version:
            continue

        if remote_head:
            package_dir = dest_root / package
            if local_head is None:
                local_head = get_local_head(package_dir)
            if local_head and local_head == remote_head:
                continue

        pending_updates.append(
            UpdateCandidate(
                name=package,
                installed_version=installed_version,
                target_version=remote_version,
                remote_head=remote_head,
                local_head=local_head,
            )
        )

    if not pending_updates:
        print("All packages are up to date.")
        if missing:
            source_label = "AUR RPC" if USE_AUR_RPC else "AUR mirror"
            for package in missing:
                print(
                    f"note: {package} is not available via {source_label}",
                    file=sys.stderr,
                )
        return

    for index, candidate in enumerate(pending_updates, start=1):
        from_version = candidate.installed_version or "?"
        if candidate.target_version:
            to_version = candidate.target_version
        elif candidate.remote_head:
            to_version = candidate.remote_head[:7]
        else:
            to_version = "unknown"
        print(f"{index}) {candidate.name} {from_version} -> {to_version}")

    interactive = sys.stdin.isatty() and sys.stdout.isatty()
    if interactive:
        selected_candidates = interactive_select_updates(pending_updates)
        if not selected_candidates:
            return
    else:
        selected_candidates = pending_updates

    shared_visited: set[str] = set()
    shared_preinstalled_official: set[str] = set()
    for candidate in selected_candidates:
        try:
            install_package(
                candidate.name,
                dest_root,
                refresh=refresh,
                noconfirm=noconfirm,
                visited=shared_visited,
                preinstalled_official=shared_preinstalled_official,
            )
        except AurGitError as exc:
            print(f"error updating {candidate.name}: {exc}", file=sys.stderr)

    for package in missing:
        if is_debug_package(package):
            continue
        source_label = "AUR RPC" if USE_AUR_RPC else "AUR mirror"
        print(f"note: {package} is not available via {source_label}", file=sys.stderr)


def search_packages(
    pattern: str,
    *,
    regex: re.Pattern | None,
    needle: str | None,
    limit: int | None,
) -> list[SearchResult]:
    # Regex requires git mirror - AUR RPC has their own regex
    # passing a pattern returns nothing, lets use grimaur's main functionality instead
    # if pattern is received use git mirror automatically and remove regex functions from RPC related
    if USE_AUR_RPC and regex is None:  # Here condion pass to git instead
        results = search_packages_rpc(
            pattern,
            needle=needle,
            limit=limit,
        )
        if results:
            return results
    return search_packages_git(
        regex=regex,
        needle=needle,
        limit=limit,
    )


def search_packages_git(
    *,
    regex: re.Pattern | None,
    needle: str | None,
    limit: int | None,
) -> list[SearchResult]:
    # Default to 50 results if no limit specified to avoid fetching metadata for thousands of packages
    if limit is None:
        limit = 50
    output = run_command(
        ["git", "ls-remote", "--heads", get_aur_remote()], capture=True
    )
    candidates: list[tuple[int, str]] = []
    for line in str(output).splitlines():
        if not line.strip():
            continue
        try:
            _, ref = line.split()
        except ValueError:
            continue
        package = ref.split("/")[-1]
        score = compute_match_score(package, regex=regex, needle=needle)
        if score is None:
            continue
        candidates.append((score, package))
        if sys.stderr.isatty():
            print(f"\r{style('Found results:', YELLOW)} {len(candidates)}", end="", file=sys.stderr, flush=True)
    if sys.stderr.isatty():
        print(file=sys.stderr)
    if limit is not None and limit >= 0:
        candidates = heapq.nsmallest(limit, candidates, key=lambda item: (item[0], item[1]))
    else:
        candidates.sort(key=lambda item: (item[0], item[1]))
    installed_set = installed_package_set()
    total_candidates = len(candidates)

    # Fetch metadata in parallel for speed
    def fetch_metadata(score_pkg):
        score, package = score_pkg
        version = None
        description = None
        meta = git_srcinfo_metadata(package)
        if meta:
            version, description = meta
        return SearchResult(
            name=package,
            version=version,
            description=description,
            installed=package in installed_set,
            score=score,
        )

    results: list[SearchResult] = []
    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(fetch_metadata, item) for item in candidates]
        for idx, future in enumerate(futures, 1):
            if sys.stderr.isatty():
                print(f"\r{style('Fetching metadata:', YELLOW)} {idx}/{total_candidates}", end="", file=sys.stderr, flush=True)
            results.append(future.result())

    if sys.stderr.isatty():
        print(file=sys.stderr)
    return results


def search_packages_rpc(
    pattern: str,
    *,
    needle: str | None,
    limit: int | None,
) -> list[SearchResult]:
    # Default to 50 results if no limit specified
    if limit is None:
        limit = 50
    raw_results = aur_rpc_search_results(pattern)
    candidates: list[tuple[int, dict]] = []
    for entry in raw_results:
        name = entry.get("Name")
        if not isinstance(name, str):
            continue
        score = compute_match_score(name, regex=None, needle=needle)
        # Note regex set to none
        if score is None:
            continue
        candidates.append((score, entry))
    candidates.sort(key=lambda item: (item[0], item[1].get("Name", "")))
    if limit is not None and limit >= 0:
        candidates = candidates[:limit]
    installed_set = installed_package_set()
    results: list[SearchResult] = []
    for score, entry in candidates:
        name_value = entry.get("Name")
        if not isinstance(name_value, str):
            continue
        version = (
            entry.get("Version") if isinstance(entry.get("Version"), str) else None
        )
        description = (
            entry.get("Description")
            if isinstance(entry.get("Description"), str)
            else None
        )
        votes = None
        votes_value = entry.get("NumVotes")
        if isinstance(votes_value, int | float | str):
            try:
                votes = int(votes_value)
            except (TypeError, ValueError):
                votes = None
        maintainer = entry.get("Maintainer")
        is_orphan = maintainer in (None, "")
        results.append(
            SearchResult(
                name=name_value,
                version=version,
                description=description,
                installed=name_value in installed_set,
                score=score,
                votes=votes,
                is_orphan=is_orphan,
            )
        )
    return results


def order_search_results(results: Sequence[SearchResult]) -> list[SearchResult]:
    # Lower score = better match; return ascending order (best last when reversed later).
    return sorted(results, key=lambda result: (result.score, result.name))


def format_search_result(index: int, result: SearchResult) -> list[str]:
    index_label = style(f"{index:>2})", CYAN)
    main_parts: list[str] = [style(result.name, BOLD)]
    if result.version:
        main_parts.append(style(result.version, GREEN))
    if result.installed:
        main_parts.append(style("[installed]", GREEN))
    # Note using votes we can know its a rpc result
    if result.votes is not None:
        protocol = "ssh" if USE_SSH else "https"
        meta_bits: list[str] = [f"{protocol} aur rpc", f"{result.votes} votes"]
        if result.is_orphan:
            meta_bits.append("orphan")
    else:
        protocol = "ssh" if USE_SSH else "https"
        meta_bits = [f"{protocol} git mirror"]
    line = f"{index_label} {' '.join(main_parts)}"
    if meta_bits:
        line += f" {style('[' + ', '.join(meta_bits) + ']', DIM)}"
    lines = [line]
    if result.description:
        # Limit description to 120 characters
        desc = result.description
        if len(desc) > 120:
            desc = desc[:117] + "..."
        lines.append(f"    {style(desc, DIM)}")
    return lines


def print_search_results(results: Sequence[SearchResult]) -> None:
    total = len(results)
    for pos, result in enumerate(results):
        display_index = total - pos
        for line in format_search_result(display_index, result):
            print(line)


def format_update_candidate(index: int, candidate: UpdateCandidate) -> list[str]:
    index_label = style(f"{index:>2})", CYAN)
    name_part = style(candidate.name, BOLD)
    current_version = candidate.installed_version or "?"
    if candidate.target_version:
        target_label = candidate.target_version
    elif candidate.remote_head:
        target_label = f"{candidate.remote_head[:7]}"
    else:
        target_label = "unknown"
    change = f"{current_version} -> {target_label}"
    meta_bits: list[str] = []
    if candidate.remote_head and not candidate.target_version:
        meta_bits.append("git commit")
    line = f"{index_label} {name_part} {style(change, GREEN)}"
    if meta_bits:
        line += f" {style('[' + ', '.join(meta_bits) + ']', DIM)}"
    return [line]


def interactive_select_updates(
    candidates: Sequence[UpdateCandidate],
) -> list[UpdateCandidate]:
    if not candidates:
        return []
    prompt_text = style(
        "Select packages to update (Enter for all, q to quit): ",
        YELLOW,
    )
    total = len(candidates)
    while True:
        try:
            raw = input(prompt_text)
        except EOFError:
            return list(candidates)
        if not raw.strip():
            return list(candidates)
        parsed = parse_selection(raw, total)
        if parsed is None:
            print(style("Invalid selection. Please try again.", YELLOW))
            continue
        if not parsed:
            return []
        selected: list[UpdateCandidate] = []
        for value in parsed:
            index = value - 1
            if index < 0 or index >= total:
                selected = []
                break
            selected.append(candidates[index])
        if not selected and parsed:
            print(style("Invalid selection. Please try again.", YELLOW))
            continue
        return selected


def parse_selection(selection: str, max_index: int) -> list[int] | None:
    selection = selection.strip().lower()
    if not selection:
        return []
    if selection in {"q", "quit"}:
        return []
    if selection in {"a", "all"}:
        return list(range(1, max_index + 1))
    chosen: set[int] = set()
    tokens = re.split(r"[\s,]+", selection)
    for token in tokens:
        if not token:
            continue
        if "-" in token:
            start_str, end_str = token.split("-", 1)
            try:
                start = int(start_str)
                end = int(end_str)
            except ValueError:
                return None
            if start > end:
                start, end = end, start
            if start < 1 or end > max_index:
                return None
            chosen.update(range(start, end + 1))
            continue
        try:
            value = int(token)
        except ValueError:
            return None
        if value < 1 or value > max_index:
            return None
        chosen.add(value)
    return sorted(chosen)


def interactive_select_results(results: Sequence[SearchResult]) -> list[SearchResult]:
    if not results:
        return []
    total = len(results)
    prompt_text = style(
        "Select packages to install (e.g. 1 3-5, a for all, q to quit): ",
        YELLOW,
    )
    while True:
        try:
            raw = input(prompt_text)
        except EOFError:
            return []
        parsed = parse_selection(raw, total)
        if parsed is None:
            print(style("Invalid selection. Please try again.", YELLOW))
            continue
        if not parsed:
            return []
        selected: list[SearchResult] = []
        for value in parsed:
            index = total - value
            selected.append(results[index])
        return selected


def complete_packages(prefix: str, limit: int) -> list[str]:
    if USE_AUR_RPC:
        names = complete_packages_rpc(prefix, limit)
        if names or USE_AUR_RPC:
            return names
    return complete_packages_git(prefix, limit)


def complete_packages_git(prefix: str, limit: int) -> list[str]:
    prefix = prefix.strip()
    if not prefix:
        return []
    pattern = f"refs/heads/{prefix}*"
    try:
        output = run_command(
            ["git", "ls-remote", "--heads", get_aur_remote(), pattern],
            capture=True,
        )
    except AurGitError:
        return []
    names: list[str] = []
    for line in str(output).splitlines():
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) != 2:
            continue
        ref = parts[1]
        name = ref.split("/")[-1]
        names.append(name)
        if len(names) >= limit:
            break
    return names


def complete_packages_rpc(prefix: str, limit: int) -> list[str]:
    prefix = prefix.strip()
    if not prefix:
        return []
    suggestions = aur_rpc_suggest(prefix)
    names: list[str] = []
    seen: set[str] = set()
    for suggestion in suggestions:
        if not suggestion.startswith(prefix):
            continue
        if suggestion in seen:
            continue
        seen.add(suggestion)
        names.append(suggestion)
        if len(names) >= limit:
            break
    return names


def inspect_package(
    package: str,
    dest_root: Path,
    *,
    refresh: bool,
    target: str,
    show_deps: bool,
    repo_url: str | None = None,
) -> None:
    if USE_AUR_RPC and target == "info" and not repo_url:
        info = aur_rpc_info(package)
        if info:
            deps = dependency_set_from_rpc(info)
            print(f"Package: {package}")
            description = (
                info.get("Description")
                if isinstance(info.get("Description"), str)
                else None
            )
            if description:
                print(f"Description: {description}")
            if deps.depends:
                print("Depends:")
                for dep in sorted(deps.depends):
                    print(f"  {dep}")
            else:
                print("Depends: (none)")
            if show_deps:
                if deps.makedepends:
                    print("Make depends:")
                    for dep in sorted(deps.makedepends):
                        print(f"  {dep}")
                else:
                    print("Make depends: (none)")
                if deps.checkdepends:
                    print("Check depends:")
                    for dep in sorted(deps.checkdepends):
                        print(f"  {dep}")
                else:
                    print("Check depends: (none)")
                if deps.optdepends:
                    print("Optional:")
                    for dep in sorted(deps.optdepends):
                        print(f"  {dep}")
                else:
                    print("Optional: (none)")
            return
        if USE_AUR_RPC:
            raise AurGitError(f"Package '{package}' not found via AUR RPC")

    package_dir = ensure_clone(package, dest_root, refresh=refresh, repo_url=repo_url)
    if target == "PKGBUILD":
        pkgbuild_path = package_dir / "PKGBUILD"
        if not pkgbuild_path.exists():
            raise AurGitError(f"PKGBUILD not found at {pkgbuild_path}")
        print(pkgbuild_path.read_text())
        return
    if target == "SRCINFO":
        print(read_srcinfo(package_dir))
        return

    srcinfo = read_srcinfo(package_dir)
    _, pkgdesc, deps = parse_dependencies(srcinfo)
    print(f"Package: {package}")
    if pkgdesc:
        print(f"Description: {pkgdesc}")
    if deps.depends:
        print("Depends:")
        for dep in sorted(deps.depends):
            print(f"  {dep}")
    else:
        print("Depends: (none)")
    if show_deps:
        if deps.makedepends:
            print("Make depends:")
            for dep in sorted(deps.makedepends):
                print(f"  {dep}")
        else:
            print("Make depends: (none)")
        if deps.checkdepends:
            print("Check depends:")
            for dep in sorted(deps.checkdepends):
                print(f"  {dep}")
        else:
            print("Check depends: (none)")
        if deps.optdepends:
            print("Optional:")
            for dep in sorted(deps.optdepends):
                print(f"  {dep}")
        else:
            print("Optional: (none)")


def fetch_package(
    package: str,
    dest_root: Path,
    *,
    refresh: bool,
    force: bool,
    repo_url: str | None = None,
) -> Path:
    package_dir = ensure_clone(
        package, dest_root, refresh=refresh, force_reclone=force, repo_url=repo_url
    )
    print(f"Package fetched to {package_dir}")
    return package_dir


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Work with AUR packages via the git mirror or AUR RPC"
    )
    parser.add_argument(
        "--dest-root",
        default="~/.cache/aurgit",
        help="Directory to store cloned packages (default: ~/.cache/aurgit)",
    )
    parser.add_argument(
        "--refresh", action="store_true", help="Refresh existing clones before use"
    )
    parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable coloured output",
    )
    parser.add_argument(
        "--aur-rpc",
        dest="aur_rpc",
        action="store_true",
        default=True,
        help="Use the AUR RPC API for metadata and dependency resolution (default)",
    )
    parser.add_argument(
        "--git-mirror",
        dest="aur_rpc",
        action="store_false",
        help="Use the git mirror for metadata and dependency resolution",
    )
    parser.add_argument(
        "--use-ssh",
        action="store_true",
        help="Use SSH instead of HTTPS for git operations",
    )
    subparsers = parser.add_subparsers(dest="command")

    fetch_parser = subparsers.add_parser(
        "fetch", help="Clone the package branch locally"
    )
    fetch_parser.add_argument("package", help="Package name / branch to clone")
    fetch_parser.add_argument(
        "--force", action="store_true", help="Reclone even if directory exists"
    )
    fetch_parser.add_argument("--repo-url", help="Clone from custom Git URL")

    install_parser = subparsers.add_parser(
        "install", help="Resolve dependencies and build/install a package"
    )
    install_parser.add_argument("package", help="Package name to install")
    install_parser.add_argument(
        "--noconfirm", action="store_true", help="Pass --noconfirm to pacman/makepkg"
    )
    install_parser.add_argument("--repo-url", help="Clone from custom Git URL")

    remove_parser = subparsers.add_parser("remove", help="Remove an installed package")
    remove_parser.add_argument("package", help="Package name to remove")
    remove_parser.add_argument(
        "--noconfirm", action="store_true", help="Pass --noconfirm to pacman"
    )
    remove_parser.add_argument(
        "--remove-cache",
        action="store_true",
        help="Also remove the cached clone from dest-root",
    )

    update_parser = subparsers.add_parser(
        "update",
        help="Upgrade installed foreign packages by rebuilding them from the mirror",
    )
    update_parser.add_argument(
        "packages",
        nargs="*",
        help="Specific foreign package names to update (default: all from pacman -Qm)",
    )
    update_parser.add_argument(
        "--noconfirm", action="store_true", help="Pass --noconfirm to pacman/makepkg"
    )
    update_parser.add_argument(
        "--devel",
        action="store_true",
        help="Include VCS/devel packages (e.g. *-git) when checking for updates",
    )
    update_parser.add_argument(
        "--global",
        action="store_true",
        help="Update official repositories with pacman -Syu before updating AUR packages",
    )
    global_group = update_parser.add_mutually_exclusive_group()
    update_parser.add_argument(
        "--system-only",
        action="store_true",
        help="With --global, only update system packages and skip AUR updates",
    )
    global_group.add_argument(
        "--index",
        action="store_true",
        help="With --global, only sync package databases (pacman -Sy)",
    )
    global_group.add_argument(
        "--download",
        action="store_true",
        help="With --global, download updates without installing (pacman -Syuw)",
    )
    global_group.add_argument(
        "--install",
        action="store_true",
        help="With --global, install already-downloaded packages (pacman -Su)",
    )
    search_parser = subparsers.add_parser(
        "search", help="Search packages via the configured backend"
    )
    search_parser.add_argument(
        "pattern", help="Substring or regex to match against package names"
    )
    search_parser.add_argument(
        "--limit", type=int, help="Limit results to the first N matches"
    )
    search_parser.add_argument(
        "--no-interactive",
        action="store_true",
        help="Disable interactive selection and only list results",
    )
    search_parser.add_argument(
        "--noconfirm",
        action="store_true",
        help="Skip confirmation prompts when installing from search",
    )

    complete_parser = subparsers.add_parser("complete", help=argparse.SUPPRESS)
    complete_parser.add_argument("subcommand", choices=["install"])
    complete_parser.add_argument("prefix", nargs="?", default="")
    complete_parser.add_argument(
        "--limit",
        type=int,
        default=64,
        help="Limit number of completion candidates (default: 64)",
    )

    inspect_parser = subparsers.add_parser(
        "inspect", help="Show PKGBUILD or dependency information"
    )
    inspect_parser.add_argument("package", help="Package name to inspect")
    inspect_parser.add_argument(
        "--target",
        choices=["info", "PKGBUILD", "SRCINFO"],
        default="info",
        help="Which data to show (default: info)",
    )
    inspect_parser.add_argument(
        "--full",
        action="store_true",
        help="Include make/check/optional dependencies when showing info",
    )
    inspect_parser.add_argument(
        "--repo-url", help="Inspect package from custom Git URL"
    )
    subparsers.add_parser("list", help="List installed foreign (AUR) packages")

    return parser


def main(argv: Sequence[str] | None = None) -> int:
    argv_list = list(argv if argv is not None else sys.argv[1:])
    commands = {
        "fetch",
        "install",
        "remove",
        "update",
        "search",
        "inspect",
        "complete",
        "list",
    }
    if argv_list and not argv_list[0].startswith("-") and argv_list[0] not in commands:
        reordered: list[str] = []
        remaining: list[str] = []
        i = 0
        while i < len(argv_list):
            item = argv_list[i]
            if item == "--":
                remaining.extend(argv_list[i:])
                break
            if item in _GLOBAL_FLAG_OPTIONS:
                reordered.append(item)
            elif any(item.startswith(f"{opt}=") for opt in _GLOBAL_VALUE_OPTIONS):
                reordered.append(item)
            elif item in _GLOBAL_VALUE_OPTIONS:
                reordered.append(item)
                if i + 1 < len(argv_list):
                    reordered.append(argv_list[i + 1])
                    i += 1
            else:
                remaining.append(item)
            i += 1
        else:
            # ensure natural exit when loop completes without break
            pass
        argv_list = reordered + ["search"] + remaining

    parser = build_parser()
    args = parser.parse_args(argv_list)

    dest_root = Path(os.path.expanduser(args.dest_root)).resolve()
    refresh: bool = bool(args.refresh)
    if args.command is None:
        parser.print_help()
        return 0

    global USE_COLOR, USE_AUR_RPC, FORCE_GIT_MIRROR, USE_SSH
    USE_COLOR = not getattr(args, "no_color", False) and sys.stdout.isatty()
    USE_AUR_RPC = bool(getattr(args, "aur_rpc", True))
    FORCE_GIT_MIRROR = not USE_AUR_RPC
    USE_SSH = bool(getattr(args, "use_ssh", False))

    try:
        if args.command == "fetch":
            fetch_package(
                args.package,
                dest_root,
                refresh=refresh,
                force=args.force,
                repo_url=getattr(args, "repo_url", None),
            )
        elif args.command == "install":
            preinstalled_official: set[str] | None = None
            repo_url = getattr(args, "repo_url", None)
            if USE_AUR_RPC and not repo_url:
                missing_official, unresolved = collect_missing_official_packages(
                    args.package,
                    dest_root,
                    refresh=refresh,
                )
                if unresolved:
                    missing_list = ", ".join(sorted(unresolved))
                    raise AurGitError(
                        f"Could not resolve providers for: {missing_list}"
                    )
                if missing_official:
                    install_official_packages(
                        missing_official,
                        noconfirm=args.noconfirm,
                    )
                preinstalled_official = set(missing_official)
            install_package(
                args.package,
                dest_root,
                refresh=refresh,
                noconfirm=args.noconfirm,
                preinstalled_official=preinstalled_official,
                repo_url=repo_url,
            )
        elif args.command == "remove":
            remove_package(
                args.package,
                dest_root,
                noconfirm=args.noconfirm,
                remove_cache=args.remove_cache,
            )
        elif args.command == "update":
            update_packages(
                dest_root,
                refresh=True,
                noconfirm=args.noconfirm,
                include_devel=bool(getattr(args, "devel", False)),
                update_system=bool(getattr(args, "global", False)),
                targets=args.packages or None,
                system_only=bool(getattr(args, "system_only", False)),
                index_only=bool(getattr(args, "index", False)),
                download_only=bool(getattr(args, "download", False)),
                install_only=bool(getattr(args, "install", False)),
            )
        elif args.command == "search":
            regex_obj: re.Pattern | None = None
            needle: str | None = None
            # Auto-detect regex or allow explicit --regex flag
            use_regex = is_regex(args.pattern)
            if use_regex:
                try:
                    regex_obj = re.compile(args.pattern)
                except re.error as exc:
                    print(f"error: invalid regular expression: {exc}", file=sys.stderr)
                    return 1
                # Regex search requires git mirror, disable AUR RPC
                USE_AUR_RPC = False
            else:
                needle = args.pattern.lower()
            results = search_packages(
                args.pattern,
                regex=regex_obj,
                needle=needle,
                limit=args.limit,
            )
            if not results:
                print("No matches found", file=sys.stderr)
                return 1

            ordered_results = order_search_results(results)
            display_results = list(reversed(ordered_results))
            print(style("Search results (best matches last):", CYAN))
            print_search_results(display_results)

            interactive = (
                not args.no_interactive and sys.stdin.isatty() and sys.stdout.isatty()
            )
            if not interactive:
                return 0

            selected = interactive_select_results(display_results)
            if not selected:
                print(style("No packages selected.", DIM))
                return 0

            print(style("Installing selected packages:", CYAN))
            for item in selected:
                label = style(item.name, BOLD)
                if item.version:
                    label = f"{label} {style(item.version, GREEN)}"
                print(f"  {label}")

            exit_code = 0
            shared_visited: set[str] = set()
            shared_preinstalled_official: set[str] = set()
            for item in selected:
                try:
                    install_package(
                        item.name,
                        dest_root,
                        refresh=refresh,
                        noconfirm=args.noconfirm,
                        visited=shared_visited,
                        preinstalled_official=shared_preinstalled_official,
                    )
                except AurGitError as exc:
                    exit_code = 1
                    print(f"error installing {item.name}: {exc}", file=sys.stderr)
            return exit_code
        elif args.command == "complete":
            prefix = args.prefix
            limit = max(1, args.limit)
            names: list[str] = []
            if args.subcommand == "install":
                names = complete_packages(prefix, limit)
            for name in names:
                print(name)
            return 0
        elif args.command == "inspect":
            inspect_package(
                args.package,
                dest_root,
                refresh=refresh,
                target="PKGBUILD"
                if args.target == "PKGBUILD"
                else ("SRCINFO" if args.target == "SRCINFO" else "info"),
                show_deps=args.full,
                repo_url=getattr(args, "repo_url", None),
            )
        elif args.command == "list":
            list_installed_packages()
        else:
            parser.error("Unknown command")
    except AurGitError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 1

    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\n" + style("Interrupted by user", YELLOW), file=sys.stderr)
        sys.exit(130)
